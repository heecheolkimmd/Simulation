# -*- coding: utf-8 -*-
"""taxi_simulation_ny12

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mV6iaWW5TK4lGNv11xlS3-HIQbwav0Dr
"""

import osmnx as ox
import networkx as nx
import numpy as np
import random
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from collections import deque

# Q-Learning 에이전트 (빈 상태의 택시가 다음 이동을 결정)
class QLearningAgent:
    def __init__(self, alpha=0.1, gamma=0.9, epsilon=0.1):
        self.alpha = alpha      # 학습률
        self.gamma = gamma      # 할인율
        self.epsilon = epsilon  # 탐험 확률
        self.q_table = {}       # 키: ((current, destination), action)

    def get_q_value(self, state, action):
        return self.q_table.get((state, action), 0.0)

    def choose_action(self, state, valid_actions):
        # 유효 행동이 없는 경우, 현재 노드에 머무르도록 반환
        if not valid_actions:
            return state[0]
        if random.random() < self.epsilon:
            return random.choice(valid_actions)
        else:
            q_values = [self.get_q_value(state, a) for a in valid_actions]
            max_q = max(q_values)
            best_actions = [a for a, q in zip(valid_actions, q_values) if q == max_q]
            return random.choice(best_actions)

    def learn(self, state, action, reward, next_state, next_valid_actions):
        old_q = self.get_q_value(state, action)
        if next_valid_actions:
            next_max_q = max([self.get_q_value(next_state, a) for a in next_valid_actions])
        else:
            next_max_q = 0.0
        new_q = old_q + self.alpha * (reward + self.gamma * next_max_q - old_q)
        self.q_table[(state, action)] = new_q

# 도로 네트워크 기반 택시 환경 (승객 요청 생성 및 글로벌 배차 적용)
class TaxiEnvironment:
    def __init__(self, num_taxis=50, max_steps=1000, passenger_spawn_prob=0.2):
        # "Manhattan, New York City, USA" 영역의 도로 네트워크를 simplify 옵션으로 가져옵니다.
        place = "Manhattan, New York City, USA"
        self.graph = ox.graph_from_place(place, network_type='drive', simplify=True)
        self.nodes = list(self.graph.nodes())
        self.num_taxis = num_taxis
        self.max_steps = max_steps
        self.time_step = 0
        self.passenger_spawn_prob = passenger_spawn_prob
        # 승객 요청: key: passenger id, value: {"position": 노드, "destination": 노드}
        self.passengers = {}
        self.passenger_id_counter = 1
        # 각 택시 초기 상태: 모두 빈 상태("empty")
        self.taxis = []
        for _ in range(num_taxis):
            start = random.choice(self.nodes)
            self.taxis.append({
                'position': start,
                'status': 'empty',         # "empty", "to_pickup", "occupied"
                'assigned_passenger': None,
                'path': deque(),           # 이동 경로 (노드들의 deque)
                'pickup_node': None,       # 승객 픽업 위치 (할당 시 저장)
                'destination': None        # 승객 목적지 (픽업 후 저장)
            })

    def reset(self):
        self.time_step = 0
        self.passengers = {}
        self.passenger_id_counter = 1
        self.taxis = []
        for _ in range(self.num_taxis):
            start = random.choice(self.nodes)
            self.taxis.append({
                'position': start,
                'status': 'empty',
                'assigned_passenger': None,
                'path': deque(),
                'pickup_node': None,
                'destination': None
            })
        return self.get_state()

    def spawn_passenger(self):
        # 승객 호출 확률을 높여 승객 요청이 많이 생성되도록 함.
        if random.random() < self.passenger_spawn_prob:
            pid = f"P{self.passenger_id_counter}"
            self.passenger_id_counter += 1
            pos = random.choice(self.nodes)
            dest = random.choice(self.nodes)
            while dest == pos:
                dest = random.choice(self.nodes)
            self.passengers[pid] = {"position": pos, "destination": dest}

    def global_assignment(self, rewards):
        # 먼저, 빈 택시 중 현재 위치에 승객 요청이 있는 경우 바로 할당
        for i, taxi in enumerate(self.taxis):
            if taxi['status'] == 'empty':
                for pid, pdata in list(self.passengers.items()):
                    if pdata["position"] == taxi['position']:
                        taxi['assigned_passenger'] = pid
                        taxi['destination'] = pdata["destination"]
                        try:
                            route = nx.shortest_path(self.graph, taxi['position'], taxi['destination'])
                        except Exception:
                            route = []
                        taxi['path'] = deque(route[1:]) if route else deque()
                        taxi['status'] = 'occupied'
                        rewards[i] = 10
                        self.passengers.pop(pid)
                        break
        # 남은 승객 요청에 대해, 모든 빈 택시에 대해 가장 가까운 승객 요청을 할당
        available_indices = [i for i, taxi in enumerate(self.taxis) if taxi['status'] == 'empty']
        for pid in list(self.passengers.keys()):
            best_taxi = None
            best_route = None
            best_dist = float('inf')
            for i in available_indices:
                try:
                    route = nx.shortest_path(self.graph, self.taxis[i]['position'], self.passengers[pid]["position"])
                    dist = len(route)
                    if dist < best_dist:
                        best_dist = dist
                        best_taxi = i
                        best_route = route
                except Exception:
                    continue
            if best_taxi is not None:
                taxi = self.taxis[best_taxi]
                taxi['assigned_passenger'] = pid
                taxi['pickup_node'] = self.passengers[pid]["position"]
                taxi['path'] = deque(best_route[1:]) if best_route else deque()
                taxi['status'] = 'to_pickup'
                rewards[best_taxi] = 5
                available_indices.remove(best_taxi)
                self.passengers.pop(pid)

    def step(self, actions):
        rewards = [0] * self.num_taxis
        # 매 스텝마다 승객 요청 생성
        self.spawn_passenger()
        # 글로벌 배차: 가장 가까운 빈 택시에게 승객 요청 할당
        self.global_assignment(rewards)

        # 각 택시의 상태에 따른 이동 처리 (모든 택시는 한 스텝에 인접 노드로 동일 이동)
        for i, taxi in enumerate(self.taxis):
            if taxi['status'] == 'empty':
                # 승객 요청이 없는 경우, 에이전트 선택 행동 수행
                valid_actions = self.get_valid_actions(taxi['position'])
                action = actions[i]
                taxi['position'] = action
                rewards[i] = -1
            elif taxi['status'] == 'to_pickup':
                # 픽업을 위해 미리 계산된 경로 따라 이동
                if taxi['path']:
                    taxi['position'] = taxi['path'].popleft()
                rewards[i] = -1
                if taxi['position'] == taxi['pickup_node']:
                    # 픽업 완료 후, 승객 목적지로 이동 경로 계산
                    if taxi['destination'] is None:
                        new_dest = random.choice(self.nodes)
                        while new_dest == taxi['position']:
                            new_dest = random.choice(self.nodes)
                        taxi['destination'] = new_dest
                    try:
                        route = nx.shortest_path(self.graph, taxi['position'], taxi['destination'])
                    except Exception:
                        route = []
                    taxi['path'] = deque(route[1:]) if route else deque()
                    taxi['status'] = 'occupied'
                    rewards[i] += 10
            elif taxi['status'] == 'occupied':
                if taxi['path']:
                    taxi['position'] = taxi['path'].popleft()
                rewards[i] = -1
                if taxi['destination'] is not None and taxi['position'] == taxi['destination']:
                    rewards[i] += 100
                    taxi['status'] = 'empty'
                    taxi['assigned_passenger'] = None
                    taxi['path'] = deque()
                    taxi['pickup_node'] = None
                    taxi['destination'] = None
        self.time_step += 1
        done = self.time_step >= self.max_steps
        return self.get_state(), rewards, done

    def get_state(self):
        # 각 택시 상태: (현재 노드, 상태, 목적지(있으면))
        states = []
        for taxi in self.taxis:
            states.append((taxi['position'], taxi['status'], taxi.get('destination', None)))
        return states

    def get_valid_actions(self, node):
        return list(self.graph.neighbors(node))

    def get_node_positions(self):
        pos = {node: (data['x'], data['y']) for node, data in self.graph.nodes(data=True)}
        return pos

# 시각화 함수: 도로 네트워크, 택시 위치, 경로, 승객 요청 표시
def visualize_environment(env, ax, pos):
    ax.clear()
    # 도로 네트워크 엣지 그리기
    for u, v in env.graph.edges():
        x_vals = [pos[u][0], pos[v][0]]
        y_vals = [pos[u][1], pos[v][1]]
        ax.plot(x_vals, y_vals, color='gray', linewidth=0.5, alpha=0.5)

    # 택시 및 경로 그리기
    for i, taxi in enumerate(env.taxis):
        taxi_pos = pos[taxi['position']]
        ax.scatter(taxi_pos[0], taxi_pos[1], c='blue', s=10, zorder=5)
        ax.text(taxi_pos[0], taxi_pos[1], f"T{i}", fontsize=5, fontweight='bold',
                ha='center', va='bottom', color='black')
        if taxi['path']:
            route_nodes = [taxi['position']] + list(taxi['path'])
            route_coords = [pos[node] for node in route_nodes]
            xs = [p[0] for p in route_coords]
            ys = [p[1] for p in route_coords]
            if taxi['status'] == 'to_pickup':
                ax.scatter(taxi_pos[0], taxi_pos[1], c='orange', s=10, zorder=5)
                ax.plot(xs, ys, color='orange', linestyle='--', linewidth=1)
            elif taxi['status'] == 'occupied':
                ax.scatter(taxi_pos[0], taxi_pos[1], c='red', s=10, zorder=5)
                ax.plot(xs, ys, color='green', linestyle='--', linewidth=1)
        if taxi.get('destination', None) is not None:
            dest_pos = pos[taxi['destination']]
            ax.scatter(dest_pos[0], dest_pos[1], c='green', s=10, zorder=5)
            ax.text(dest_pos[0], dest_pos[1], f"D{i}", fontsize=5, fontweight='bold',
                    ha='center', va='bottom', color='black')

    # 승객 요청 표시: 승객의 호출(픽업) 노드는 오렌지 색, 목적지는 녹색 색
    for pid, pdata in env.passengers.items():
        p_pos = pos[pdata["position"]]
        d_pos = pos[pdata["destination"]]
        # 픽업 위치: 오렌지색 (marker 크기 약간 키움)
        ax.scatter(p_pos[0], p_pos[1], color='orange', s=20, zorder=6)
        ax.text(p_pos[0], p_pos[1], f"{pid}", fontsize=5, fontweight='bold',
                ha='center', va='top', color='orange')
        ax.scatter(d_pos[0], d_pos[1], color='green', s=10, zorder=5)
        ax.text(d_pos[0], d_pos[1], f"D{pid}", fontsize=5, fontweight='bold',
                ha='center', va='top', color='green')

    ax.set_title(f"Step: {env.time_step}")
    ax.axis('equal')
    ax.axis('off')

# 메인 함수
def main():
    env = TaxiEnvironment(num_taxis=50, max_steps=1000, passenger_spawn_prob=2)
    state = env.reset()

    # 각 택시마다 Q-Learning 에이전트를 생성 (빈 상태 이동 결정용)
    agents = [QLearningAgent(alpha=0.1, gamma=0.9, epsilon=0.2) for _ in range(env.num_taxis)]
    pos = env.get_node_positions()

    fig, ax = plt.subplots(figsize=(8, 8))

    def update(frame):
        states = env.get_state()  # 각 택시 상태: (현재 노드, 상태, 목적지)
        actions = []
        for i, taxi_state in enumerate(states):
            if taxi_state[1] == 'empty':
                valid_actions = env.get_valid_actions(taxi_state[0])
                action = agents[i].choose_action(taxi_state, valid_actions)
            else:
                action = taxi_state[0]
            actions.append(action)
        next_states, rewards, done = env.step(actions)
        for i, taxi_state in enumerate(states):
            next_valid_actions = env.get_valid_actions(next_states[i][0])
            agents[i].learn(taxi_state, actions[i], rewards[i], next_states[i], next_valid_actions)
        visualize_environment(env, ax, pos)
        if done:
            ani.event_source.stop()

    # 시뮬레이션 속도를 5배 빠르게: interval=1ms (너무 빠르면 시스템에 따라 조정)
    ani = FuncAnimation(fig, update, frames=range(env.max_steps), interval=2, repeat=False)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()