# -*- coding: utf-8 -*-
"""taxi_simulation7

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mV6iaWW5TK4lGNv11xlS3-HIQbwav0Dr
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from collections import deque

# 사용할 스타일을 변경 (예: 'ggplot' 스타일 사용)
plt.style.use('ggplot')

# 환경 클래스 정의
class TaxiEnvironment:
    def __init__(self, grid_size=50, num_taxis=50, passenger_spawn_prob=0.1):
        self.grid_size = grid_size
        self.num_taxis = num_taxis
        self.passenger_spawn_prob = passenger_spawn_prob
        self.taxis = [{'position': (random.randint(0, grid_size-1), random.randint(0, grid_size-1)),
                       'status': 'empty', 'pickups': 0, 'assigned_passenger': None, 'path': deque()}
                      for _ in range(num_taxis)]
        self.passengers = {}
        self.destinations = {}
        self.waiting_times = {}
        self.time_step = 0
        self.passenger_id_counter = 1

    def reset(self):
        self.taxis = [{'position': (random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1)),
                       'status': 'empty', 'pickups': 0, 'assigned_passenger': None, 'path': deque()}
                      for _ in range(self.num_taxis)]
        self.passengers = {}
        self.destinations = {}
        self.waiting_times = {}
        self.time_step = 0
        self.passenger_id_counter = 1
        self._spawn_initial_passengers()
        return self.get_state()

    def _spawn_initial_passengers(self):
        for _ in range(3):
            self._spawn_passenger()

    def _spawn_passenger(self):
        passenger_id = f'P{self.passenger_id_counter}'
        self.passenger_id_counter += 1
        passenger_pos = (random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1))
        destination_pos = (random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1))
        while passenger_pos == destination_pos:
            destination_pos = (random.randint(0, self.grid_size-1), random.randint(0, self.grid_size-1))
        self.passengers[passenger_id] = passenger_pos
        self.destinations[passenger_id] = destination_pos
        self.waiting_times[passenger_id] = 0

    def step(self, actions):
        rewards = [0] * self.num_taxis

        for passenger_id in list(self.waiting_times.keys()):
            if passenger_id in self.passengers:
                self.waiting_times[passenger_id] += 1

        assignments = []
        for passenger_id, pos in list(self.passengers.items()):
            waiting = self.waiting_times[passenger_id]
            for i, taxi in enumerate(self.taxis):
                if taxi['status'] == 'empty':
                    dist = abs(taxi['position'][0] - pos[0]) + abs(taxi['position'][1] - pos[1])
                    score = waiting - dist
                    assignments.append((score, passenger_id, pos, i, dist))
        assignments.sort(key=lambda x: x[0], reverse=True)
        for score, passenger_id, pos, taxi_idx, dist in assignments:
            if passenger_id in self.passengers and self.taxis[taxi_idx]['status'] == 'empty':
                taxi = self.taxis[taxi_idx]
                taxi['assigned_passenger'] = passenger_id
                taxi['status'] = 'to_pickup'
                taxi['target'] = pos
                taxi['path'] = self._find_shortest_path(taxi['position'], pos)
                del self.passengers[passenger_id]

        for i, action in enumerate(actions):
            taxi = self.taxis[i]
            if taxi['status'] == 'to_pickup':
                if taxi['path']:
                    next_pos = taxi['path'].popleft()
                    taxi['position'] = next_pos
                if taxi['position'] == taxi.get('target', None):
                    passenger_id = taxi['assigned_passenger']
                    reward = 10 - self.waiting_times.get(passenger_id, 0)
                    destination = self.destinations[passenger_id]
                    taxi['path'] = self._find_shortest_path(taxi['position'], destination)
                    taxi['status'] = 'occupied'
                    taxi.pop('target', None)
                    rewards[i] = reward
                else:
                    rewards[i] = -1

            elif taxi['status'] == 'occupied':
                if taxi['path']:
                    next_pos = taxi['path'].popleft()
                    taxi['position'] = next_pos
                    if taxi['position'] == self.destinations[taxi['assigned_passenger']]:
                        passenger_id = taxi['assigned_passenger']
                        taxi['status'] = 'empty'
                        taxi['assigned_passenger'] = None
                        taxi['pickups'] += 1
                        taxi['path'].clear()
                        rewards[i] = 20
                        del self.destinations[passenger_id]
                        del self.waiting_times[passenger_id]
                        self._spawn_passenger()
                    else:
                        rewards[i] = -1
                else:
                    self.move_taxi(i, action)
                    rewards[i] = -1

            elif taxi['status'] == 'empty':
                if action == 'pickup':
                    for passenger_id, pos in list(self.passengers.items()):
                        if pos == taxi['position']:
                            taxi['status'] = 'occupied'
                            taxi['assigned_passenger'] = passenger_id
                            taxi['pickups'] += 1
                            taxi['path'] = self._find_shortest_path(taxi['position'], self.destinations[passenger_id])
                            rewards[i] = 10 - self.waiting_times[passenger_id]
                            del self.passengers[passenger_id]
                            break
                    else:
                        rewards[i] = -1
                else:
                    if self.passengers:
                        xs = [pos[0] for pos in self.passengers.values()]
                        ys = [pos[1] for pos in self.passengers.values()]
                        centroid_x = sum(xs) / len(xs)
                        centroid_y = sum(ys) / len(ys)
                        x, y = taxi['position']
                        dx = centroid_x - x
                        dy = centroid_y - y
                        if abs(dx) > abs(dy):
                            new_action = 'down' if dx > 0 else 'up'
                        else:
                            new_action = 'right' if dy > 0 else 'left'
                        self.move_taxi(i, new_action)
                        rewards[i] = -1
                    else:
                        self.move_taxi(i, action)
                        rewards[i] = -1

        if random.random() < self.passenger_spawn_prob:
            self._spawn_passenger()

        self.time_step += 1
        done = self.time_step >= 10000
        return self.get_state(), rewards, done

    def move_taxi(self, taxi_idx, action):
        x, y = self.taxis[taxi_idx]['position']
        if action == 'up':
            x = max(0, x - 1)
        elif action == 'down':
            x = min(self.grid_size - 1, x + 1)
        elif action == 'left':
            y = max(0, y - 1)
        elif action == 'right':
            y = min(self.grid_size - 1, y + 1)
        self.taxis[taxi_idx]['position'] = (x, y)

    def _find_shortest_path(self, start, goal):
        queue = deque([(start, [start])])
        visited = set([start])
        while queue:
            (x, y), path = queue.popleft()
            if (x, y) == goal:
                return deque(path[1:])
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < self.grid_size and 0 <= ny < self.grid_size and (nx, ny) not in visited:
                    visited.add((nx, ny))
                    queue.append(((nx, ny), path + [(nx, ny)]))
        return deque()

    def get_state(self):
        return {
            'taxis': [(t['position'], t['status'], t['pickups'], t['assigned_passenger'], list(t['path']))
                      for t in self.taxis],
            'passengers': self.passengers,
            'destinations': self.destinations,
            'waiting_times': self.waiting_times
        }

# Q-Learning 에이전트 클래스 정의
class QLearningAgent:
    def __init__(self, actions, alpha=0.1, gamma=0.9, epsilon=0.1):
        self.actions = actions
        self.alpha = alpha
        self.gamma = gamma
        self.epsilon = epsilon
        self.q_table = {}

    def get_q_value(self, state, action):
        return self.q_table.get((state, action), 0.0)

    def choose_action(self, state):
        if random.random() < self.epsilon:
            return random.choice(self.actions)
        else:
            q_values = [self.get_q_value(state, a) for a in self.actions]
            max_q = max(q_values)
            return random.choice([a for a, q in zip(self.actions, q_values) if q == max_q])

    def learn(self, state, action, reward, next_state):
        old_q = self.get_q_value(state, action)
        next_max_q = max([self.get_q_value(next_state, a) for a in self.actions])
        new_q = old_q + self.alpha * (reward + self.gamma * next_max_q - old_q)
        self.q_table[(state, action)] = new_q

# grid 시각화 함수 (깔끔한 텍스트와 레이아웃 적용)
def visualize_environment(env, ax_grid):
    ax_grid.clear()
    for passenger_id, pos in env.passengers.items():
        ax_grid.text(pos[1], pos[0], passenger_id, color='blue',
                     ha='center', va='center', fontsize=12, fontweight='bold')
    for passenger_id, pos in env.destinations.items():
        ax_grid.text(pos[1], pos[0], f'D{passenger_id[1:]}', color='green',
                     ha='center', va='center', fontsize=12, fontweight='bold')
    for i, taxi in enumerate(env.taxis):
        color = 'red' if taxi['status'] == 'empty' else 'orange'
        ax_grid.text(taxi['position'][1], taxi['position'][0], f'T{i}', color=color,
                     ha='center', va='center', fontsize=16, fontweight='bold')
        if taxi['status'] == 'occupied' and taxi['path']:
            path_x = [taxi['position'][1]] + [p[1] for p in taxi['path']]
            path_y = [taxi['position'][0]] + [p[0] for p in taxi['path']]
            ax_grid.plot(path_x, path_y, color='gray', linestyle='--', linewidth=1)
        elif taxi['status'] == 'to_pickup' and taxi['path']:
            path_x = [taxi['position'][1]] + [p[1] for p in taxi['path']]
            path_y = [taxi['position'][0]] + [p[0] for p in taxi['path']]
            ax_grid.plot(path_x, path_y, color='purple', linestyle='--', linewidth=1)
    ax_grid.set_xticks(np.arange(-0.5, env.grid_size, 1))
    ax_grid.set_yticks(np.arange(-0.5, env.grid_size, 1))
    ax_grid.set_xticklabels([])
    ax_grid.set_yticklabels([])
    ax_grid.grid(True, linestyle=':', linewidth=0.5)

    taxi_pickups = [taxi['pickups'] for taxi in env.taxis]
    waiting_times_str = ', '.join([f"{p}: {t}" for p, t in env.waiting_times.items()])
    title_text = (
        f"Step: {env.time_step}\n\n"
        f"택시별 승객 탑승 횟수:\n" +
        "\n".join([f"T{i}: {p}" for i, p in enumerate(taxi_pickups)]) +
        f"\n\n대기 시간:\n{waiting_times_str}"
    )
    ax_grid.set_title(title_text, fontsize=10, loc='left')

# 히스토그램 업데이트 함수 (택시 승객 탑승 횟수 및 순위)
def update_histogram(env, ax_hist):
    taxi_pickups = [taxi['pickups'] for taxi in env.taxis]
    sorted_taxis = sorted(enumerate(taxi_pickups), key=lambda x: x[1], reverse=True)
    x_labels = [f"Rank {i+1}\n(T{taxi_idx})" for i, (taxi_idx, count) in enumerate(sorted_taxis)]
    pickups_sorted = [count for taxi_idx, count in sorted_taxis]
    ax_hist.clear()
    bars = ax_hist.bar(x_labels, pickups_sorted, color='skyblue')
    ax_hist.set_title("택시 승객 탑승 횟수 (순위)", fontsize=12, fontweight='bold')
    ax_hist.set_xlabel("택시 (순위)", fontsize=10)
    ax_hist.set_ylabel("승객 탑승 횟수", fontsize=10)
    for bar in bars:
        height = bar.get_height()
        ax_hist.annotate(f'{height}',
                         xy=(bar.get_x() + bar.get_width() / 2, height),
                         xytext=(0, 3), textcoords="offset points",
                         ha='center', va='bottom', fontsize=9, fontweight='bold')
    ax_hist.set_ylim(0, max(pickups_sorted)+5 if pickups_sorted else 5)

def main():
    env = TaxiEnvironment(grid_size=50, num_taxis=50, passenger_spawn_prob=0.1)
    actions = ['up', 'down', 'left', 'right', 'pickup', 'dropoff']
    agents = [QLearningAgent(actions) for _ in range(env.num_taxis)]
    fig, (ax_grid, ax_hist) = plt.subplots(1, 2, figsize=(16, 8))

    def update(frame):
        state = env.get_state()
        state_str = str(state)
        actions_list = [agent.choose_action(state_str) for agent in agents]
        next_state, rewards, done = env.step(actions_list)
        next_state_str = str(next_state)
        for i, agent in enumerate(agents):
            agent.learn(state_str, actions_list[i], rewards[i], next_state_str)
        visualize_environment(env, ax_grid)
        update_histogram(env, ax_hist)
        if done:
            ani.event_source.stop()

    ani = FuncAnimation(fig, update, frames=range(5000), interval=200, repeat=False)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()